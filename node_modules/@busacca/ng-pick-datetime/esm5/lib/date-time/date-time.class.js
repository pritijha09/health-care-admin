import { __decorate, __param } from "tslib";
/**
 * date-time.class
 */
import { Inject, Input, Optional, Directive } from '@angular/core';
import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { DateTimeAdapter } from './adapter/date-time-adapter.class';
import { OWL_DATE_TIME_FORMATS } from './adapter/date-time-format.class';
var nextUniqueId = 0;
var OwlDateTime = /** @class */ (function () {
    function OwlDateTime(dateTimeAdapter, dateTimeFormats) {
        var _this = this;
        this.dateTimeAdapter = dateTimeAdapter;
        this.dateTimeFormats = dateTimeFormats;
        /**
         * Whether to show the second's timer
         * @default false
         * @type {Boolean}
         * */
        this._showSecondsTimer = false;
        /**
         * Whether the timer is in hour12 format
         * @default false
         * @type {boolean}
         * */
        this._hour12Timer = false;
        /**
         * The view that the calendar should start in.
         * @default {'month'}
         * @type {'month' | 'year' | 'multi-years'}
         * */
        this.startView = 'month';
        /**
         * Hours to change per step
         * @default {1}
         * @type {number}
         * */
        this._stepHour = 1;
        /**
         * Minutes to change per step
         * @default {1}
         * @type {number}
         * */
        this._stepMinute = 1;
        /**
         * Seconds to change per step
         * @default {1}
         * @type {number}
         * */
        this._stepSecond = 1;
        /**
         * Set the first day of week
         * @default {0} -- 0: Sunday ~ 6: Saturday
         * @type {number}
         * */
        this._firstDayOfWeek = 0;
        /**
         * Whether to hide dates in other months at the start or end of the current month.
         * @default {false}
         * @type {boolean}
         * */
        this._hideOtherMonths = false;
        /**
         * Date Time Checker to check if the give dateTime is selectable
         * @type {Function}
         * */
        this.dateTimeChecker = function (dateTime) {
            return !!dateTime &&
                (!_this.dateTimeFilter || _this.dateTimeFilter(dateTime)) &&
                (!_this.minDateTime || _this.dateTimeAdapter.compare(dateTime, _this.minDateTime) >= 0) &&
                (!_this.maxDateTime || _this.dateTimeAdapter.compare(dateTime, _this.maxDateTime) <= 0);
        };
        if (!this.dateTimeAdapter) {
            throw Error("OwlDateTimePicker: No provider found for DateTimeAdapter. You must import one of the following " +
                "modules at your application root: OwlNativeDateTimeModule, OwlMomentDateTimeModule, or provide a " +
                "custom implementation.");
        }
        if (!this.dateTimeFormats) {
            throw Error("OwlDateTimePicker: No provider found for OWL_DATE_TIME_FORMATS. You must import one of the following " +
                "modules at your application root: OwlNativeDateTimeModule, OwlMomentDateTimeModule, or provide a " +
                "custom implementation.");
        }
        this._id = "owl-dt-picker-" + nextUniqueId++;
    }
    Object.defineProperty(OwlDateTime.prototype, "showSecondsTimer", {
        get: function () {
            return this._showSecondsTimer;
        },
        set: function (val) {
            this._showSecondsTimer = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "hour12Timer", {
        get: function () {
            return this._hour12Timer;
        },
        set: function (val) {
            this._hour12Timer = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "stepHour", {
        get: function () {
            return this._stepHour;
        },
        set: function (val) {
            this._stepHour = coerceNumberProperty(val, 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "stepMinute", {
        get: function () {
            return this._stepMinute;
        },
        set: function (val) {
            this._stepMinute = coerceNumberProperty(val, 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "stepSecond", {
        get: function () {
            return this._stepSecond;
        },
        set: function (val) {
            this._stepSecond = coerceNumberProperty(val, 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "firstDayOfWeek", {
        get: function () {
            return this._firstDayOfWeek;
        },
        set: function (value) {
            value = coerceNumberProperty(value, 0);
            if (value > 6 || value < 0) {
                this._firstDayOfWeek = 0;
            }
            else {
                this._firstDayOfWeek = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "hideOtherMonths", {
        get: function () {
            return this._hideOtherMonths;
        },
        set: function (val) {
            this._hideOtherMonths = coerceBooleanProperty(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "formatString", {
        get: function () {
            return this.pickerType === 'both' ? this.dateTimeFormats.fullPickerInput :
                this.pickerType === 'calendar' ? this.dateTimeFormats.datePickerInput :
                    this.dateTimeFormats.timePickerInput;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OwlDateTime.prototype, "disabled", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param obj The object to check.
     * @returns The given object if it is both a date instance and valid, otherwise null.
     */
    OwlDateTime.prototype.getValidDate = function (obj) {
        return (this.dateTimeAdapter.isDateInstance(obj) && this.dateTimeAdapter.isValid(obj)) ? obj : null;
    };
    OwlDateTime.ctorParameters = function () { return [
        { type: DateTimeAdapter, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [OWL_DATE_TIME_FORMATS,] }] }
    ]; };
    __decorate([
        Input()
    ], OwlDateTime.prototype, "showSecondsTimer", null);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "hour12Timer", null);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "startView", void 0);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "stepHour", null);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "stepMinute", null);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "stepSecond", null);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "firstDayOfWeek", null);
    __decorate([
        Input()
    ], OwlDateTime.prototype, "hideOtherMonths", null);
    OwlDateTime = __decorate([
        Directive(),
        __param(0, Optional()),
        __param(1, Optional()), __param(1, Inject(OWL_DATE_TIME_FORMATS))
    ], OwlDateTime);
    return OwlDateTime;
}());
export { OwlDateTime };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS10aW1lLmNsYXNzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGJ1c2FjY2EvbmctcGljay1kYXRldGltZS8iLCJzb3VyY2VzIjpbImxpYi9kYXRlLXRpbWUvZGF0ZS10aW1lLmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7R0FFRztBQUNILE9BQU8sRUFBZ0IsTUFBTSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3BGLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUNwRSxPQUFPLEVBQUUscUJBQXFCLEVBQXNCLE1BQU0sa0NBQWtDLENBQUM7QUFFN0YsSUFBSSxZQUFZLEdBQUcsQ0FBQyxDQUFDO0FBU3JCO0lBbUxJLHFCQUFtQyxlQUFtQyxFQUNKLGVBQW1DO1FBRHJHLGlCQWlCQztRQWpCa0Msb0JBQWUsR0FBZixlQUFlLENBQW9CO1FBQ0osb0JBQWUsR0FBZixlQUFlLENBQW9CO1FBbExyRzs7OzthQUlLO1FBQ0csc0JBQWlCLEdBQUcsS0FBSyxDQUFDO1FBVWxDOzs7O2FBSUs7UUFDRyxpQkFBWSxHQUFHLEtBQUssQ0FBQztRQVU3Qjs7OzthQUlLO1FBQ0ksY0FBUyxHQUFxQyxPQUFPLENBQUM7UUFFL0Q7Ozs7YUFJSztRQUNHLGNBQVMsR0FBRyxDQUFDLENBQUM7UUFVdEI7Ozs7YUFJSztRQUNHLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBVXhCOzs7O2FBSUs7UUFDRyxnQkFBVyxHQUFHLENBQUMsQ0FBQztRQVV4Qjs7OzthQUlLO1FBQ0csb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFlNUI7Ozs7YUFJSztRQUNHLHFCQUFnQixHQUFHLEtBQUssQ0FBQztRQXVEakM7OzthQUdLO1FBQ0Usb0JBQWUsR0FBRyxVQUFFLFFBQVc7WUFDbEMsT0FBTyxDQUFD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RGhDLFNBQVMsRUFBRTtRQW9MTSxXQUFBLFFBQVEsRUFBRSxDQUFBO1FBQ1YsV0FBQSxRQUFRLEVBQUUsQ0FBQSxFQUFFLFdBQUEsTUFBTSxDQUFDLHFCQUFxQixDQUFDLENBQUE7T0FwTHJDLFdBQVcsQ0E2TWhDO0lBQUQsa0JBQUM7Q0FBQSxBQTdNRCxJQTZNQztTQTdNcUIsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBkYXRlLXRpbWUuY2xhc3NcclxuICovXHJcbmltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5qZWN0LCBJbnB1dCwgT3B0aW9uYWwsIERpcmVjdGl2ZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBjb2VyY2VCb29sZWFuUHJvcGVydHksIGNvZXJjZU51bWJlclByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcclxuaW1wb3J0IHsgRGF0ZVRpbWVBZGFwdGVyIH0gZnJvbSAnLi9hZGFwdGVyL2RhdGUtdGltZS1hZGFwdGVyLmNsYXNzJztcclxuaW1wb3J0IHsgT1dMX0RBVEVfVElNRV9GT1JNQVRTLCBPd2xEYXRlVGltZUZvcm1hdHMgfSBmcm9tICcuL2FkYXB0ZXIvZGF0ZS10aW1lLWZvcm1hdC5jbGFzcyc7XHJcblxyXG5sZXQgbmV4dFVuaXF1ZUlkID0gMDtcclxuXHJcbmV4cG9ydCB0eXBlIFBpY2tlclR5cGUgPSAnYm90aCcgfCAnY2FsZW5kYXInIHwgJ3RpbWVyJztcclxuXHJcbmV4cG9ydCB0eXBlIFBpY2tlck1vZGUgPSAncG9wdXAnIHwgJ2RpYWxvZycgfCAnaW5saW5lJztcclxuXHJcbmV4cG9ydCB0eXBlIFNlbGVjdE1vZGUgPSAnc2luZ2xlJyB8ICdyYW5nZScgfCAncmFuZ2VGcm9tJyB8ICdyYW5nZVRvJztcclxuXHJcbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIE93bERhdGVUaW1lPFQ+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdG8gc2hvdyB0aGUgc2Vjb25kJ3MgdGltZXJcclxuICAgICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cclxuICAgICAqICovXHJcbiAgICBwcml2YXRlIF9zaG93U2Vjb25kc1RpbWVyID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IHNob3dTZWNvbmRzVGltZXIoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3dTZWNvbmRzVGltZXI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHNob3dTZWNvbmRzVGltZXIoIHZhbDogYm9vbGVhbiApIHtcclxuICAgICAgICB0aGlzLl9zaG93U2Vjb25kc1RpbWVyID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSB0aW1lciBpcyBpbiBob3VyMTIgZm9ybWF0XHJcbiAgICAgKiBAZGVmYXVsdCBmYWxzZVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiAqL1xyXG4gICAgcHJpdmF0ZSBfaG91cjEyVGltZXIgPSBmYWxzZTtcclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgaG91cjEyVGltZXIoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hvdXIxMlRpbWVyO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBob3VyMTJUaW1lciggdmFsOiBib29sZWFuICkge1xyXG4gICAgICAgIHRoaXMuX2hvdXIxMlRpbWVyID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdmlldyB0aGF0IHRoZSBjYWxlbmRhciBzaG91bGQgc3RhcnQgaW4uXHJcbiAgICAgKiBAZGVmYXVsdCB7J21vbnRoJ31cclxuICAgICAqIEB0eXBlIHsnbW9udGgnIHwgJ3llYXInIHwgJ211bHRpLXllYXJzJ31cclxuICAgICAqICovXHJcbiAgICBASW5wdXQoKSBzdGFydFZpZXc6ICdtb250aCcgfCAneWVhcicgfCAnbXVsdGkteWVhcnMnID0gJ21vbnRoJztcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvdXJzIHRvIGNoYW5nZSBwZXIgc3RlcFxyXG4gICAgICogQGRlZmF1bHQgezF9XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogKi9cclxuICAgIHByaXZhdGUgX3N0ZXBIb3VyID0gMTtcclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgc3RlcEhvdXIoKTogbnVtYmVyIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RlcEhvdXI7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHN0ZXBIb3VyKCB2YWw6IG51bWJlciApIHtcclxuICAgICAgICB0aGlzLl9zdGVwSG91ciA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbCwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNaW51dGVzIHRvIGNoYW5nZSBwZXIgc3RlcFxyXG4gICAgICogQGRlZmF1bHQgezF9XHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICogKi9cclxuICAgIHByaXZhdGUgX3N0ZXBNaW51dGUgPSAxO1xyXG4gICAgQElucHV0KClcclxuICAgIGdldCBzdGVwTWludXRlKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0ZXBNaW51dGU7XHJcbiAgICB9XHJcblxyXG4gICAgc2V0IHN0ZXBNaW51dGUoIHZhbDogbnVtYmVyICkge1xyXG4gICAgICAgIHRoaXMuX3N0ZXBNaW51dGUgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWwsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2Vjb25kcyB0byBjaGFuZ2UgcGVyIHN0ZXBcclxuICAgICAqIEBkZWZhdWx0IHsxfVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqICovXHJcbiAgICBwcml2YXRlIF9zdGVwU2Vjb25kID0gMTtcclxuICAgIEBJbnB1dCgpXHJcbiAgICBnZXQgc3RlcFNlY29uZCgpOiBudW1iZXIge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGVwU2Vjb25kO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBzdGVwU2Vjb25kKCB2YWw6IG51bWJlciApIHtcclxuICAgICAgICB0aGlzLl9zdGVwU2Vjb25kID0gY29lcmNlTnVtYmVyUHJvcGVydHkodmFsLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgZmlyc3QgZGF5IG9mIHdlZWtcclxuICAgICAqIEBkZWZhdWx0IHswfSAtLSAwOiBTdW5kYXkgfiA2OiBTYXR1cmRheVxyXG4gICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAqICovXHJcbiAgICBwcml2YXRlIF9maXJzdERheU9mV2VlayA9IDA7XHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGZpcnN0RGF5T2ZXZWVrKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9maXJzdERheU9mV2VlaztcclxuICAgIH1cclxuXHJcbiAgICBzZXQgZmlyc3REYXlPZldlZWsoIHZhbHVlOiBudW1iZXIgKSB7XHJcbiAgICAgICAgdmFsdWUgPSBjb2VyY2VOdW1iZXJQcm9wZXJ0eSh2YWx1ZSwgMCk7XHJcbiAgICAgICAgaWYgKHZhbHVlID4gNiB8fCB2YWx1ZSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3REYXlPZldlZWsgPSAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0RGF5T2ZXZWVrID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0byBoaWRlIGRhdGVzIGluIG90aGVyIG1vbnRocyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBjdXJyZW50IG1vbnRoLlxyXG4gICAgICogQGRlZmF1bHQge2ZhbHNlfVxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKiAqL1xyXG4gICAgcHJpdmF0ZSBfaGlkZU90aGVyTW9udGhzID0gZmFsc2U7XHJcbiAgICBASW5wdXQoKVxyXG4gICAgZ2V0IGhpZGVPdGhlck1vbnRocygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGlkZU90aGVyTW9udGhzO1xyXG4gICAgfVxyXG5cclxuICAgIHNldCBoaWRlT3RoZXJNb250aHModmFsOiBib29sZWFuKSB7XHJcbiAgICAgICAgdGhpcy5faGlkZU90aGVyTW9udGhzID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfaWQ6IHN0cmluZztcclxuICAgIGdldCBpZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcclxuICAgIH1cclxuXHJcbiAgICBhYnN0cmFjdCBnZXQgc2VsZWN0ZWQoKTogVCB8IG51bGw7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IHNlbGVjdGVkcygpOiBUW10gfCBudWxsO1xyXG5cclxuICAgIGFic3RyYWN0IGdldCBkYXRlVGltZUZpbHRlcigpOiAoIGRhdGU6IFQgfCBudWxsICkgPT4gYm9vbGVhbjtcclxuXHJcbiAgICBhYnN0cmFjdCBnZXQgbWF4RGF0ZVRpbWUoKTogVCB8IG51bGw7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IG1pbkRhdGVUaW1lKCk6IFQgfCBudWxsO1xyXG5cclxuICAgIGFic3RyYWN0IGdldCBzZWxlY3RNb2RlKCk6IFNlbGVjdE1vZGU7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IHN0YXJ0QXQoKTogVCB8IG51bGw7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IG9wZW5lZCgpOiBib29sZWFuO1xyXG5cclxuICAgIGFic3RyYWN0IGdldCBwaWNrZXJNb2RlKCk6IFBpY2tlck1vZGU7XHJcblxyXG4gICAgYWJzdHJhY3QgZ2V0IHBpY2tlclR5cGUoKTogUGlja2VyVHlwZTtcclxuXHJcbiAgICBhYnN0cmFjdCBnZXQgaXNJblNpbmdsZU1vZGUoKTogYm9vbGVhbjtcclxuXHJcbiAgICBhYnN0cmFjdCBnZXQgaXNJblJhbmdlTW9kZSgpOiBib29sZWFuO1xyXG5cclxuICAgIGFic3RyYWN0IHNlbGVjdCggZGF0ZTogVCB8IFRbXSApOiB2b2lkO1xyXG5cclxuICAgIGFic3RyYWN0IHllYXJTZWxlY3RlZDogRXZlbnRFbWl0dGVyPFQ+O1xyXG5cclxuICAgIGFic3RyYWN0IG1vbnRoU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxUPjtcclxuXHJcbiAgICBhYnN0cmFjdCBzZWxlY3RZZWFyKCBub3JtYWxpemVkWWVhcjogVCApOiB2b2lkO1xyXG5cclxuICAgIGFic3RyYWN0IHNlbGVjdE1vbnRoKCBub3JtYWxpemVkTW9udGg6IFQgKTogdm9pZDtcclxuXHJcbiAgICBnZXQgZm9ybWF0U3RyaW5nKCk6IHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VyVHlwZSA9PT0gJ2JvdGgnID8gdGhpcy5kYXRlVGltZUZvcm1hdHMuZnVsbFBpY2tlcklucHV0IDpcclxuICAgICAgICAgICAgdGhpcy5waWNrZXJUeXBlID09PSAnY2FsZW5kYXInID8gdGhpcy5kYXRlVGltZUZvcm1hdHMuZGF0ZVBpY2tlcklucHV0IDpcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0ZVRpbWVGb3JtYXRzLnRpbWVQaWNrZXJJbnB1dDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERhdGUgVGltZSBDaGVja2VyIHRvIGNoZWNrIGlmIHRoZSBnaXZlIGRhdGVUaW1lIGlzIHNlbGVjdGFibGVcclxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cclxuICAgICAqICovXHJcbiAgICBwdWJsaWMgZGF0ZVRpbWVDaGVja2VyID0gKCBkYXRlVGltZTogVCApID0+IHtcclxuICAgICAgICByZXR1cm4gISFkYXRlVGltZSAmJlxyXG4gICAgICAgICAgICAoIXRoaXMuZGF0ZVRpbWVGaWx0ZXIgfHwgdGhpcy5kYXRlVGltZUZpbHRlcihkYXRlVGltZSkpICYmXHJcbiAgICAgICAgICAgICghdGhpcy5taW5EYXRlVGltZSB8fCB0aGlzLmRhdGVUaW1lQWRhcHRlci5jb21wYXJlKGRhdGVUaW1lLCB0aGlzLm1pbkRhdGVUaW1lKSA+PSAwKSAmJlxyXG4gICAgICAgICAgICAoIXRoaXMubWF4RGF0ZVRpbWUgfHwgdGhpcy5kYXRlVGltZUFkYXB0ZXIuY29tcGFyZShkYXRlVGltZSwgdGhpcy5tYXhEYXRlVGltZSkgPD0gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdHJ1Y3RvciggQE9wdGlvbmFsKCkgcHJvdGVjdGVkIGRhdGVUaW1lQWRhcHRlcjogRGF0ZVRpbWVBZGFwdGVyPFQ+LFxyXG4gICAgICAgICAgICAgICAgIEBPcHRpb25hbCgpIEBJbmplY3QoT1dMX0RBVEVfVElNRV9GT1JNQVRTKSBwcm90ZWN0ZWQgZGF0ZVRpbWVGb3JtYXRzOiBPd2xEYXRlVGltZUZvcm1hdHMgKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmRhdGVUaW1lQWRhcHRlcikge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcclxuICAgICAgICAgICAgICAgIGBPd2xEYXRlVGltZVBpY2tlcjogTm8gcHJvdmlkZXIgZm91bmQgZm9yIERhdGVUaW1lQWRhcHRlci4gWW91IG11c3QgaW1wb3J0IG9uZSBvZiB0aGUgZm9sbG93aW5nIGAgK1xyXG4gICAgICAgICAgICAgICAgYG1vZHVsZXMgYXQgeW91ciBhcHBsaWNhdGlvbiByb290OiBPd2xOYXRpdmVEYXRlVGltZU1vZHVsZSwgT3dsTW9tZW50RGF0ZVRpbWVNb2R1bGUsIG9yIHByb3ZpZGUgYSBgICtcclxuICAgICAgICAgICAgICAgIGBjdXN0b20gaW1wbGVtZW50YXRpb24uYCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIXRoaXMuZGF0ZVRpbWVGb3JtYXRzKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgYE93bERhdGVUaW1lUGlja2VyOiBObyBwcm92aWRlciBmb3VuZCBmb3IgT1dMX0RBVEVfVElNRV9GT1JNQVRTLiBZb3UgbXVzdCBpbXBvcnQgb25lIG9mIHRoZSBmb2xsb3dpbmcgYCArXHJcbiAgICAgICAgICAgICAgICBgbW9kdWxlcyBhdCB5b3VyIGFwcGxpY2F0aW9uIHJvb3Q6IE93bE5hdGl2ZURhdGVUaW1lTW9kdWxlLCBPd2xNb21lbnREYXRlVGltZU1vZHVsZSwgb3IgcHJvdmlkZSBhIGAgK1xyXG4gICAgICAgICAgICAgICAgYGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5gKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX2lkID0gYG93bC1kdC1waWNrZXItJHtuZXh0VW5pcXVlSWQrK31gO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9iaiBUaGUgb2JqZWN0IHRvIGNoZWNrLlxyXG4gICAgICogQHJldHVybnMgVGhlIGdpdmVuIG9iamVjdCBpZiBpdCBpcyBib3RoIGEgZGF0ZSBpbnN0YW5jZSBhbmQgdmFsaWQsIG90aGVyd2lzZSBudWxsLlxyXG4gICAgICovXHJcbiAgICBwcm90ZWN0ZWQgZ2V0VmFsaWREYXRlKCBvYmo6IGFueSApOiBUIHwgbnVsbCB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmRhdGVUaW1lQWRhcHRlci5pc0RhdGVJbnN0YW5jZShvYmopICYmIHRoaXMuZGF0ZVRpbWVBZGFwdGVyLmlzVmFsaWQob2JqKSkgPyBvYmogOiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG4iXX0=